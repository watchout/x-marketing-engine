/**
 * è¨­å®šç®¡ç†ã‚µãƒ¼ãƒãƒ¼
 * 
 * ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã‹ã‚‰ã®è¨­å®šä¿å­˜ã‚’å—ã‘ä»˜ã‘ã€
 * .env.api ã¨ GitHub Secrets ã«åæ˜ ã™ã‚‹
 */

import * as http from 'http';
import * as fs from 'fs';
import * as path from 'path';
import { execSync } from 'child_process';

const PORT = 3001;
const PROJECT_ROOT = path.join(__dirname, '..');
const ENV_FILE = path.join(PROJECT_ROOT, '.env.api');

// è¨­å®šé …ç›®ã®å®šç¾©
const SECRET_KEYS = [
  // X (Twitter) èªè¨¼
  'X_USERNAME',
  'X_PASSWORD',
  'X_API_KEY',
  'X_API_SECRET',
  'X_ACCESS_TOKEN',
  'X_ACCESS_SECRET',
  'X_BEARER_TOKEN',
  // AI API
  'OPENAI_API_KEY',
  'GROK_API_KEY',
  'GOOGLE_AI_API_KEY',
];

// .env.api ã‚’èª­ã¿è¾¼ã¿
function loadEnv(): Record<string, string> {
  const env: Record<string, string> = {};
  
  if (!fs.existsSync(ENV_FILE)) {
    return env;
  }
  
  const content = fs.readFileSync(ENV_FILE, 'utf-8');
  for (const line of content.split('\n')) {
    const trimmed = line.trim();
    if (trimmed && !trimmed.startsWith('#')) {
      const eqIndex = trimmed.indexOf('=');
      if (eqIndex !== -1) {
        const key = trimmed.substring(0, eqIndex).trim();
        let value = trimmed.substring(eqIndex + 1).trim();
        if ((value.startsWith('"') && value.endsWith('"')) ||
            (value.startsWith("'") && value.endsWith("'"))) {
          value = value.slice(1, -1);
        }
        env[key] = value;
      }
    }
  }
  
  return env;
}

// .env.api ã«ä¿å­˜
function saveEnv(env: Record<string, string>): void {
  const lines: string[] = [
    '# X Marketing Engine - API Keys & Secrets',
    '# Generated by settings server',
    '',
    '# X (Twitter) Login Credentials',
  ];
  
  if (env.X_USERNAME) lines.push(`X_USERNAME=${env.X_USERNAME}`);
  if (env.X_PASSWORD) lines.push(`X_PASSWORD=${env.X_PASSWORD}`);
  
  lines.push('', '# X (Twitter) API Credentials');
  if (env.X_API_KEY) lines.push(`X_API_KEY=${env.X_API_KEY}`);
  if (env.X_API_SECRET) lines.push(`X_API_SECRET=${env.X_API_SECRET}`);
  if (env.X_ACCESS_TOKEN) lines.push(`X_ACCESS_TOKEN=${env.X_ACCESS_TOKEN}`);
  if (env.X_ACCESS_SECRET) lines.push(`X_ACCESS_SECRET=${env.X_ACCESS_SECRET}`);
  if (env.X_BEARER_TOKEN) lines.push(`X_BEARER_TOKEN=${env.X_BEARER_TOKEN}`);
  
  lines.push('', '# AI API Keys');
  if (env.OPENAI_API_KEY) lines.push(`OPENAI_API_KEY=${env.OPENAI_API_KEY}`);
  if (env.GROK_API_KEY) lines.push(`GROK_API_KEY=${env.GROK_API_KEY}`);
  if (env.GOOGLE_AI_API_KEY) lines.push(`GOOGLE_AI_API_KEY=${env.GOOGLE_AI_API_KEY}`);
  
  lines.push('');
  
  fs.writeFileSync(ENV_FILE, lines.join('\n'));
  console.log('âœ… .env.api ã‚’ä¿å­˜ã—ã¾ã—ãŸ');
}

// GitHub Secrets ã«åŒæœŸ
function syncToGitHub(env: Record<string, string>): { success: string[]; failed: string[] } {
  const success: string[] = [];
  const failed: string[] = [];
  
  // X_USERNAME ã¨ X_PASSWORD ã¯ GitHub Secrets ã«è¿½åŠ 
  // ãã®ä»–ã¯ã™ã§ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã‚’æ›´æ–°
  const keysToSync = SECRET_KEYS.filter(key => env[key]);
  
  for (const key of keysToSync) {
    try {
      execSync(`gh secret set ${key} --body "${env[key]}"`, {
        cwd: PROJECT_ROOT,
        stdio: 'pipe'
      });
      success.push(key);
      console.log(`  âœ… ${key}`);
    } catch (error) {
      failed.push(key);
      console.log(`  âŒ ${key}`);
    }
  }
  
  return { success, failed };
}

// CORS ãƒ˜ãƒƒãƒ€ãƒ¼
function setCorsHeaders(res: http.ServerResponse): void {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
}

// ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒãƒ³ãƒ‰ãƒ©
function handleRequest(req: http.IncomingMessage, res: http.ServerResponse): void {
  setCorsHeaders(res);
  
  // OPTIONS (CORS preflight)
  if (req.method === 'OPTIONS') {
    res.writeHead(200);
    res.end();
    return;
  }
  
  const url = req.url || '/';
  
  // GET /api/settings - ç¾åœ¨ã®è¨­å®šã‚’å–å¾—
  if (req.method === 'GET' && url === '/api/settings') {
    const env = loadEnv();
    
    // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯ãƒã‚¹ã‚¯
    const masked: Record<string, string> = {};
    for (const key of SECRET_KEYS) {
      if (env[key]) {
        if (key.includes('PASSWORD') || key.includes('SECRET') || key.includes('KEY') || key.includes('TOKEN')) {
          // æœ€å¾Œã®4æ–‡å­—ä»¥å¤–ã‚’ãƒã‚¹ã‚¯
          const val = env[key];
          masked[key] = val.length > 4 ? '*'.repeat(val.length - 4) + val.slice(-4) : '****';
        } else {
          masked[key] = env[key];
        }
      } else {
        masked[key] = '';
      }
    }
    
    // è¨­å®šæ¸ˆã¿ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°ã‚‚è¿”ã™
    const configured: Record<string, boolean> = {};
    for (const key of SECRET_KEYS) {
      configured[key] = !!env[key];
    }
    
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ masked, configured }));
    return;
  }
  
  // POST /api/settings - è¨­å®šã‚’ä¿å­˜
  if (req.method === 'POST' && url === '/api/settings') {
    let body = '';
    req.on('data', chunk => { body += chunk; });
    req.on('end', () => {
      try {
        const newSettings = JSON.parse(body) as Record<string, string>;
        
        // æ—¢å­˜ã®è¨­å®šã‚’èª­ã¿è¾¼ã¿
        const env = loadEnv();
        
        // æ–°ã—ã„è¨­å®šã‚’ãƒãƒ¼ã‚¸ï¼ˆç©ºã§ãªã„å€¤ã®ã¿ï¼‰
        for (const [key, value] of Object.entries(newSettings)) {
          if (SECRET_KEYS.includes(key) && value && !value.startsWith('*')) {
            env[key] = value;
          }
        }
        
        // .env.api ã«ä¿å­˜
        saveEnv(env);
        
        // GitHub Secrets ã«åŒæœŸ
        console.log('\nğŸ“¤ GitHub Secrets ã«åŒæœŸä¸­...');
        const { success, failed } = syncToGitHub(env);
        
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({
          message: 'è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ',
          github_sync: {
            success: success.length,
            failed: failed.length,
            details: { success, failed }
          }
        }));
      } catch (error: any) {
        res.writeHead(400, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: error.message }));
      }
    });
    return;
  }
  
  // 404
  res.writeHead(404, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({ error: 'Not found' }));
}

// ã‚µãƒ¼ãƒãƒ¼èµ·å‹•
const server = http.createServer(handleRequest);

server.listen(PORT, () => {
  console.log(`
ğŸ”§ è¨­å®šã‚µãƒ¼ãƒãƒ¼èµ·å‹•
================================
URL: http://localhost:${PORT}

ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ:
  GET  /api/settings  - ç¾åœ¨ã®è¨­å®šã‚’å–å¾—
  POST /api/settings  - è¨­å®šã‚’ä¿å­˜

ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã®è¨­å®šç”»é¢ã‹ã‚‰æ“ä½œã§ãã¾ã™ã€‚
`);
});
